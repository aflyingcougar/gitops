---
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: kube-prometheus
spec:
  values:
    nameOverride: ""
    namespaceOverride: ""
    fullnameOverride: ""
    commonLabels: {}
    defaultRules:
      create: true
      rules:
        alertmanager: true
        etcd: true
        general: true
        k8s: true
        kubeApiserver: true
        kubeApiserverAvailability: true
        kubeApiserverError: true
        kubeApiserverSlos: true
        kubelet: true
        kubePrometheusGeneral: true
        kubePrometheusNodeAlerting: true
        kubePrometheusNodeRecording: true
        kubernetesAbsent: true
        kubernetesApps: true
        kubernetesResources: true
        kubernetesStorage: true
        kubernetesSystem: true
        kubeScheduler: true
        kubeStateMetrics: true
        network: true
        node: true
        prometheus: true
        prometheusOperator: true
        time: true
      appNamespacesTarget: ".*"
      labels: {}
      annotations: {}
      additionalRuleLabels: {}
    additionalPrometheusRulesMap: {}
    global:
      rbac:
        create: true
        pspEnabled: true
        pspAnnotations: {}
      imagePullSecrets: []
    alertmanager:
      enabled: true
      annotations: {}
      config:
        global:
          resolve_timeout: 5m
          smtp_smarthost: "${GRAFANA_SMTP_HOST_STRING}"
          smtp_from: "${SMTP_FROM}"
          smtp_auth_username: "${SMTP_USERNAME}"
          smtp_auth_password: "${SMTP_PASSWORD}"
          slack_api_url: "${ALERT_DISCORD_WEBHOOK_URL}/slack"
        route:
          group_by: ['job', 'alertname']
          group_wait: 30s
          group_interval: 5m
          repeat_interval: 24h
          receiver: 'discord'
          routes:
            - match:
                alertname: Watchdog
              receiver: 'null'
            - match_re:
                severity: critical|warning
              continue: true
              receiver: 'discord'
        receivers:
          - name: 'null'
          - name: 'discord'
            slack_configs:
              icon_url: https://avatars3.githubusercontent.com/u/3380462
              send_resolved: true
              title: |-
                [{{ .Status | toUpper }}{{ if eq .Status "firing" }}:{{ .Alerts.Firing | len }}{{ end }}] {{ if ne .CommonAnnotations.summary ""}}{{ .CommonAnnotations.summary }}{{ else }}{{ .CommonLabels.alertname }}{{ end }}
              text: >-
                {{ range .Alerts -}}
                  **Alert:** {{ .Annotations.title }}{{ if .Labels.severity }} - `{{ .Labels.severity }}`{{ end }}
                **Description:** {{ if ne .Annotations.description ""}}{{ .Annotations.description }}{{else}}N/A{{ end }}
                **Details:**
                  {{ range .Labels.SortedPairs }} â€¢ *{{ .Name }}:* `{{ .Value }}`
                  {{ end }}
                {{ end }}
        templates:
          - '/etc/alertmanager/config/*.tmpl'
      tplConfig: false
      templateFiles: {}
      ingress:
        enabled: true
        ingressClassName: traefik-internal
        annotations:
          hajimari.io/enable: "true"
          hajimari.io/icon: "bell-alert-outline"
          hajimari.io/appName: "Alertmanager"
          hajimari.io/group: "Observability"
        labels: {}
        hosts:
          - "alerts.${SECRET_DOMAIN}"
        paths:
          - /
        pathType: ImplementationSpecific
        tls:
          - secretName: crj-wildcard-certificate
            hosts:
              - "alerts.${SECRET_DOMAIN}"
      secret:
        annotations: {}
      ingressPerReplica:
        enabled: false
      serviceMonitor:
        selfMonitor: true
      alertmanagerSpec:
        podMetadata: {}
        image:
          repository: quay.io/prometheus/alertmanager
          tag: v0.22.2
          sha: ""
        logLevel: info
        replicas: 1
        retention: 120h
        storage:
          volumeClaimTemplate:
            spec:
              storageClassName: ceph-block
              accessModes: ["ReadWriteOnce"]
              resources:
                requests:
                  storage: 50Gi
      externalUrl: "https://alerts.${SECRET_DOMAIN}"
      nodeSelector:
        kubernetes.io/arch: "amd64"
      resources:
        requests:
          memory: 400Mi
        limits:
          memory: 1024Mi
    grafana:
      enabled: false
    kubeApiServer:
      enabled: true
      tlsConfig:
        insecureSkipVerify: true
    kubelet:
      enabled: true
    kubeControllerManager:
      enabled: true
      endpoints:
        - 192.168.130.31
        - 192.168.130.32
        - 192.168.130.33
      service:
        enabled: true
        port: 10252
        targetPort: 10252
      serviceMonitor:
        enabled: true
        interval: ""
        proxyUrl: ""
        https: false
        insecureSkipVerify: null
        serverName: null
        metricRelabelings: []
        relabelings: []
    coreDns:
      enabled: true
      service:
        port: 9153
        targetPort: 9153
      serviceMonitor:
        interval: ""
        proxyUrl: ""
        metricRelabelings: []
        relabelings: []
    kubeEtcd:
      enabled: true
      endpoints:
        - 192.168.130.31
        - 192.168.130.32
        - 192.168.130.33
      service:
        enabled: true
        port: 2379
        targetPort: 2379
      serviceMonitor:
        enabled: true
        interval: ""
        proxyUrl: ""
        scheme: http
        insecureSkipVerify: false
        serverName: ""
        caFile: ""
        certFile: ""
        keyFile: ""
        metricRelabelings: []
        relabelings: []
    kubeScheduler:
      enabled: true
      endpoints:
        - 192.168.130.31
        - 192.168.130.32
        - 192.168.130.33
      service:
        enabled: true
        port: 10251
        targetPort: 10251
      serviceMonitor:
        enabled: true
        interval: ""
        proxyUrl: ""
        https: false
        insecureSkipVerify: null
        serverName: null
        metricRelabelings: []
        relabelings: []
    kubeProxy:
      enabled: true
      endpoints:
        - 192.168.130.31
        - 192.168.130.32
        - 192.168.130.33
      service:
        enabled: true
        port: 10249
        targetPort: 10249
      serviceMonitor:
        enabled: true
        interval: ""
        proxyUrl: ""
        https: false
        metricRelabelings: []
        relabelings: []
    kubeStateMetrics:
      enabled: true
      serviceMonitor:
        interval: ""
        scrapeTimeout: ""
        proxyUrl: ""
        selectorOverride: {}
        metricRelabelings: []
        relabelings: []
        honorLabels: true
        selfMonitor:
          enabled: false
    kube-state-metrics:
      namespaceOverride: ""
      rbac:
        create: true
      podSecurityPolicy:
        enabled: true
    nodeExporter:
      enabled: true
      jobLabel: jobLabel
      serviceMonitor:
        interval: ""
        proxyUrl: ""
        scrapeTimeout: ""
        metricRelabelings: []
        relabelings: []
    prometheus-node-exporter:
      namespaceOverride: ""
      podLabels:
        jobLabel: node-exporter
      extraArgs:
        - --collector.filesystem.ignored-mount-points=^/(dev|proc|sys|var/lib/docker/.+|var/lib/kubelet/.+)($|/)
        - --collector.filesystem.ignored-fs-types=^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$
    prometheusOperator:
      enabled: true
      tls:
        enabled: true
        tlsMinVersion: VersionTLS13
        internalPort: 10250
      admissionWebhooks:
        failurePolicy: Fail
        enabled: true
        caBundle: ""
        patch:
          enabled: true
          image:
            repository: k8s.gcr.io/ingress-nginx/kube-webhook-certgen
            tag: v1.0
            sha: "f3b6b39a6062328c095337b4cadcefd1612348fdd5190b1dcbcb9b9e90bd8068"
            pullPolicy: IfNotPresent
          resources: {}
          priorityClassName: ""
          podAnnotations: {}
          nodeSelector:
            kubernetes.io/arch: "amd64"
          affinity: {}
          tolerations: []
          securityContext:
            runAsGroup: 2000
            runAsNonRoot: true
            runAsUser: 2000
        certManager:
          enabled: false
      namespaces: {}
      denyNamespaces: []
      alertmanagerInstanceNamespaces: []
      prometheusInstanceNamespaces: []
      thanosRulerInstanceNamespaces: []
      serviceAccount:
        create: true
        name: ""
      service:
        annotations: {}
        labels: {}
        clusterIP: ""
        nodePort: 30080
        nodePortTls: 30443
        additionalPorts: []
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        type: ClusterIP
        externalIPs: []
      podLabels: {}
      podAnnotations: {}
      kubeletService:
        enabled: true
        namespace: kube-system
      serviceMonitor:
        interval: ""
        scrapeTimeout: ""
        selfMonitor: true
        metricRelabelings: []
        relabelings: []
      resources: {}
      hostNetwork: false
      nodeSelector:
        kubernetes.io/arch: "amd64"
      tolerations: []
      affinity: {}
      dnsConfig: {}
      securityContext:
        fsGroup: 65534
        runAsGroup: 65534
        runAsNonRoot: true
        runAsUser: 65534
      image:
        repository: quay.io/prometheus-operator/prometheus-operator
        tag: v0.50.0
        sha: ""
        pullPolicy: IfNotPresent
      prometheusConfigReloaderImage:
        repository: quay.io/prometheus-operator/prometheus-config-reloader
        tag: v0.50.0
        sha: ""
      configReloaderCpu: 100m
      configReloaderMemory: 50Mi
      thanosImage:
        repository: quay.io/thanos/thanos
        tag: v0.17.2
        sha: ""
      secretFieldSelector: ""
    prometheus:
      enabled: true
      annotations: {}
      serviceAccount:
        create: true
        name: ""
        annotations: {}
      thanosService:
        enabled: false
        annotations: {}
        labels: {}
        type: ClusterIP
        portName: grpc
        port: 10901
        targetPort: "grpc"
        httpPortName: http
        httpPort: 10902
        targetHttpPort: "http"
        clusterIP: "None"
        nodePort: 30901
        httpNodePort: 30902
      thanosServiceMonitor:
        enabled: false
        interval: ""
        scheme: ""
        tlsConfig: {}
        bearerTokenFile:
        metricRelabelings: []
        relabelings: []
      thanosServiceExternal:
        enabled: false
        annotations: {}
        labels: {}
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        portName: grpc
        port: 10901
        targetPort: "grpc"
        httpPortName: http
        httpPort: 10902
        targetHttpPort: "http"
        type: LoadBalancer
        nodePort: 30901
        httpNodePort: 30902
      service:
        annotations: {}
        labels: {}
        clusterIP: ""
        port: 9090
        targetPort: 9090
        externalIPs: []
        nodePort: 30090
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        type: ClusterIP
        sessionAffinity: ""
      servicePerReplica:
        enabled: false
        annotations: {}
        port: 9090
        targetPort: 9090
        nodePort: 30091
        loadBalancerSourceRanges: []
        type: ClusterIP
      podDisruptionBudget:
        enabled: false
        minAvailable: 1
        maxUnavailable: ""
      thanosIngress:
        enabled: false
        annotations: {}
        labels: {}
        servicePort: 10901
        nodePort: 30901
        hosts: []
        paths: []
        tls: []
      extraSecret:
        annotations: {}
        data: {}
      ingress:
        enabled: true
        ingressClassName: traefik-internal
        annotations:
          hajimari.io/enable: "true"
          hajimari.io/icon: "fire"
          hajimari.io/appName: "Prometheus"
          hajimari.io/group: "Observability"
        labels: {}
        hosts:
          - prometheus.${SECRET_DOMAIN}
        paths:
          - /
        pathType: ImplementationSpecific
        tls:
          - secretName: crj-wildcard-certificate
            hosts:
              - prometheus.${SECRET_DOMAIN}
      ingressPerReplica:
        enabled: false
      podSecurityPolicy:
        allowedCapabilities: []
        allowedHostPaths: []
        volumes: []
      serviceMonitor:
        interval: ""
        selfMonitor: true
        scheme: ""
        tlsConfig: {}
        bearerTokenFile:
        metricRelabelings: []
        relabelings: []
      prometheusSpec:
        disableCompaction: false
        apiserverConfig: {}
        scrapeInterval: ""
        scrapeTimeout: ""
        evaluationInterval: ""
        listenLocal: false
        enableAdminAPI: false
        web: {}
        enableFeatures: []
        image:
          repository: quay.io/prometheus/prometheus
          tag: v2.28.1
          sha: ""
        tolerations: []
        topologySpreadConstraints: []
        alertingEndpoints: []
        externalLabels: {}
        replicaExternalLabelName: ""
        replicaExternalLabelNameClear: false
        prometheusExternalLabelName: ""
        prometheusExternalLabelNameClear: false
        externalUrl: ""
        nodeSelector:
          kubernetes.io/arch: "amd64"
        secrets: []
        configMaps: []
        query: {}
        ruleNamespaceSelector: {}
        ruleSelectorNilUsesHelmValues: false
        ruleSelector: {}
        serviceMonitorSelectorNilUsesHelmValues: false
        serviceMonitorSelector: {}
        serviceMonitorNamespaceSelector: {}
        podMonitorSelectorNilUsesHelmValues: false
        podMonitorSelector: {}
        podMonitorNamespaceSelector: {}
        probeSelectorNilUsesHelmValues: false
        probeSelector: {}
        probeNamespaceSelector: {}
        retention: 7d
        retentionSize: "40GB"
        walCompression: true
        paused: false
        replicas: 1
        shards: 1
        logLevel: info
        logFormat: logfmt
        routePrefix: /
        podMetadata: {}
        podAntiAffinity: ""
        podAntiAffinityTopologyKey: kubernetes.io/hostname
        affinity: {}
        remoteRead: []
        additionalRemoteRead: []
        remoteWrite: []
        additionalRemoteWrite: []
        remoteWriteDashboards: false
        resources:
          requests:
            memory: 1024Mi
          limits:
            memory: 5120Mi
        storageSpec:
          volumeClaimTemplate:
            spec:
              storageClassName: ceph-block
              accessModes: ["ReadWriteOnce"]
              resources:
                requests:
                  storage: 50Gi
        volumes: []
        volumeMounts: []
        additionalScrapeConfigs: []
        additionalScrapeConfigsSecret: {}
        additionalPrometheusSecretsAnnotations: {}
        additionalAlertManagerConfigs: []
        additionalAlertManagerConfigsSecret: {}
        additionalAlertRelabelConfigs: []
        securityContext:
          runAsGroup: 2000
          runAsNonRoot: true
          runAsUser: 1000
          fsGroup: 2000
        priorityClassName: ""
        thanos: {}
        containers: []
        initContainers: []
        portName: "web"
        arbitraryFSAccessThroughSMs: false
        overrideHonorLabels: false
        overrideHonorTimestamps: false
        ignoreNamespaceSelectors: false
        enforcedNamespaceLabel: ""
        prometheusRulesExcludedFromEnforce: []
        queryLogFile: false
        enforcedSampleLimit: false
        enforcedTargetLimit: false
        enforcedLabelLimit: false
        enforcedLabelNameLengthLimit: false
        enforcedLabelValueLengthLimit: false
        allowOverlappingBlocks: false
      additionalRulesForClusterRole: []
      additionalServiceMonitors: []
      additionalPodMonitors: []
